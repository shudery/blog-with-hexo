[
  {
    "id": 1236335,
    "slug": "boosqe",
    "title": "无标题",
    "book_id": 201855,
    "book": {
      "id": 201855,
      "type": "Column",
      "slug": "post",
      "name": "post",
      "user_id": 117222,
      "description": "技术学习",
      "creator_id": 117222,
      "public": 1,
      "items_count": 3,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-11T09:44:20.967Z",
      "updated_at": "2019-02-11T09:44:20.000Z",
      "created_at": "2019-01-10T02:22:23.000Z",
      "namespace": "daguo/post",
      "user": {
        "id": 117222,
        "type": "User",
        "login": "daguo",
        "name": "Daguo",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 2,
        "following_count": 1,
        "created_at": "2018-04-29T10:04:44.000Z",
        "updated_at": "2019-01-10T02:33:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 117222,
    "creator": {
      "id": 117222,
      "type": "User",
      "login": "daguo",
      "name": "Daguo",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 2,
      "following_count": 1,
      "created_at": "2018-04-29T10:04:44.000Z",
      "updated_at": "2019-01-10T02:33:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": null,
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-11T09:39:47.000Z",
    "deleted_at": null,
    "created_at": "2019-02-11T09:39:47.000Z",
    "updated_at": "2019-02-11T09:39:47.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1130765,
    "slug": "webpack-minipack-source",
    "title": "Webpack打包的基础原理",
    "book_id": 201855,
    "book": {
      "id": 201855,
      "type": "Column",
      "slug": "post",
      "name": "post",
      "user_id": 117222,
      "description": "技术学习",
      "creator_id": 117222,
      "public": 1,
      "items_count": 3,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-11T09:44:20.967Z",
      "updated_at": "2019-02-11T09:44:20.000Z",
      "created_at": "2019-01-10T02:22:23.000Z",
      "namespace": "daguo/post",
      "user": {
        "id": 117222,
        "type": "User",
        "login": "daguo",
        "name": "Daguo",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 2,
        "following_count": 1,
        "created_at": "2018-04-29T10:04:44.000Z",
        "updated_at": "2019-01-10T02:33:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 117222,
    "creator": {
      "id": 117222,
      "type": "User",
      "login": "daguo",
      "name": "Daguo",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 2,
      "following_count": 1,
      "created_at": "2018-04-29T10:04:44.000Z",
      "updated_at": "2019-01-10T02:33:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "最近想学习一下webpack打包的基本原理，从官方文档找到了一个推荐链接：[简单模块打包工具的细节说明](https://github.com/ronami/minipack)\n\n是一个精简的打包工具示例：minipack，里面的源码解释非常详细，介绍了一个打包工具库主要做的工作。我快速地阅读了一下源码，并做了一下翻译和总结。\n\n简单来说打包就是从一个入口文件开始，根据模块引入的语法（例如ES6的import，commonJS的require）找到所有的依赖模块，然后通过函数作用域隔离开并打包成一个单一文件。\n\n当然webpack也支持多入口打包，已经输出多个chunks打包文件，这里只是实现最简单的打包器功能，只需分三步。\n\n### 1. 找出单个模块的依赖文件\n\n在minipack中，没有选择直接对文件内容进行字符串解析，而是使用了babylon这个包来做语法解析。得到的抽象语法树AST，处理文件中的ImportDeclaration语句，即可得到文件的依赖信息，\n\n处理后同时给该文件打上标记id，每个文件模块经过处理之后会返回一个如下结构的对象：\n\n```javascript\n// Return all information about this module.\n  return {\n    id, // 模块标识\n    filename, // 模块文件的地址\n    dependencies, // 模块的依赖文件列表\n    code // 模块的代码内容\n  };\n```\n\n### 2. 获取全部模块的依赖关系\n\n接下来需要将所有文件的依赖关系联系起来，输入一个入口模块的地址，已该模块作为起点，循环搜索各个文件的依赖，直到依赖链的底层，直接贴上我对源码的注解：\n\n```javascript\n// 获取全部模块的依赖关系\nfunction createGraph(entry) {\n  // 结构化模块信息\n  const mainAsset = createAsset(entry);\n\n  // 存储模块信息到队列\n  const queue = [mainAsset];\n\n  // 使用迭代器来处理模块队列，当队列为空循环终止\n  for (const asset of queue) {\n\n    // 保存依赖关系\n    asset.mapping = {};\n    const dirname = path.dirname(asset.filename);\n    // 处理依赖子模块\n    asset.dependencies.forEach(relativePath => {\n      // 相对路径转为绝对路径\n      const absolutePath = path.join(dirname, relativePath);\n\n      // 获取依赖子模块的信息\n      const child = createAsset(absolutePath);\n\n      // 将依赖关系通过path:id的形式保存\n      asset.mapping[relativePath] = child.id;\n\n      // 存在依赖的子模块，即asset.dependencies不为空时，子模块入队列继续迭代\n      queue.push(child);\n    });\n  }\n  return queue;\n}\n```\n\n### 3. 整合为单个文件\n\n有了所有模块的依赖关系后，我们就可以将它们整合在一份文件中，通过js的function作用域去将各个模块隔离开来，仅暴露module.exports出来。\n\n将依赖信息构造成一个以id的索引的数组，数组包括两个元素：一个是以require函数，module和exports对象为入参的函数，一个是子依赖项的信息。重点在于实现require方法。\n\n在require方法中，传入模块id，根据模块id获取隔离作用域的执行函数fn以及依赖信息mapping，预处理一下require函数，目的是将模块中require函数入参的相对地址转为id，然后传入执行fn，最后返回module.exports对象给上级调用。\n\n```javascript\nfunction bundle(graph) {\n  let modules = '';\n  // 将依赖图信息列表转为一个字符串\n  graph.forEach(mod => {\n    modules += `${mod.id}: [\n      function (require, module, exports) {\n        ${mod.code}\n      },\n      ${JSON.stringify(mod.mapping)},\n    ],`;\n  });\n\n  // 实现一个自执行函数，注入modules信息\n  const result = `\n    (function(modules) {\n      function require(id) {\n        const [fn, mapping] = modules[id];\n\n        function localRequire(name) {\n          return require(mapping[name]);\n        }\n\n        const module = { exports : {} };\n\n        fn(localRequire, module, module.exports);\n\n        return module.exports;\n      }\n\n      require(0);\n    })({${modules}})\n  `;\n  // 返回单个文件输出\n  return result;\n}\n```\n\n这个方法显然是有一些瑕疵的，比如所有的模块执行require时都会执行一遍require模块的代码，可能会导致重复引入。不过通过对require方法的简单实现，已经足够让我们理解webpack这类打包工具的本质：就是通过函数来划分作用域，通过module以及module.exports来共享数据。\n\n",
    "body_draft": "",
    "body_html": "<p>最近想学习一下webpack打包的基本原理，从官方文档找到了一个推荐链接：<a href=\"https://github.com/ronami/minipack\" target=\"_blank\">简单模块打包工具的细节说明</a></p><p><br /></p><p>是一个精简的打包工具示例：minipack，里面的源码解释非常详细，介绍了一个打包工具库主要做的工作。我快速地阅读了一下源码，并做了一下翻译和总结。</p><p><br /></p><p>简单来说打包就是从一个入口文件开始，根据模块引入的语法（例如ES6的import，commonJS的require）找到所有的依赖模块，然后通过函数作用域隔离开并打包成一个单一文件。</p><p><br /></p><p>当然webpack也支持多入口打包，已经输出多个chunks打包文件，这里只是实现最简单的打包器功能，只需分三步。</p><p><br /></p><h3 id=\"d6992340\">1. 找出单个模块的依赖文件</h3><p><br /></p><p>在minipack中，没有选择直接对文件内容进行字符串解析，而是使用了babylon这个包来做语法解析。得到的抽象语法树AST，处理文件中的ImportDeclaration语句，即可得到文件的依赖信息，</p><p><br /></p><p>处理后同时给该文件打上标记id，每个文件模块经过处理之后会返回一个如下结构的对象：</p><p><br /></p><pre data-lang=\"javascript\"><code>// Return all information about this module.\n  return {\n    id, // 模块标识\n    filename, // 模块文件的地址\n    dependencies, // 模块的依赖文件列表\n    code // 模块的代码内容\n  };</code></pre><p><br /></p><h3 id=\"b7757861\">2. 获取全部模块的依赖关系</h3><p><br /></p><p>接下来需要将所有文件的依赖关系联系起来，输入一个入口模块的地址，已该模块作为起点，循环搜索各个文件的依赖，直到依赖链的底层，直接贴上我对源码的注解：</p><p><br /></p><pre data-lang=\"javascript\"><code>// 获取全部模块的依赖关系\nfunction createGraph(entry) {\n  // 结构化模块信息\n  const mainAsset = createAsset(entry);\n\n  // 存储模块信息到队列\n  const queue = [mainAsset];\n\n  // 使用迭代器来处理模块队列，当队列为空循环终止\n  for (const asset of queue) {\n\n    // 保存依赖关系\n    asset.mapping = {};\n    const dirname = path.dirname(asset.filename);\n    // 处理依赖子模块\n    asset.dependencies.forEach(relativePath =&gt; {\n      // 相对路径转为绝对路径\n      const absolutePath = path.join(dirname, relativePath);\n\n      // 获取依赖子模块的信息\n      const child = createAsset(absolutePath);\n\n      // 将依赖关系通过path:id的形式保存\n      asset.mapping[relativePath] = child.id;\n\n      // 存在依赖的子模块，即asset.dependencies不为空时，子模块入队列继续迭代\n      queue.push(child);\n    });\n  }\n  return queue;\n}</code></pre><p><br /></p><h3 id=\"767eddd8\">3. 整合为单个文件</h3><p><br /></p><p>有了所有模块的依赖关系后，我们就可以将它们整合在一份文件中，通过js的function作用域去将各个模块隔离开来，仅暴露module.exports出来。</p><p><br /></p><p>将依赖信息构造成一个以id的索引的数组，数组包括两个元素：一个是以require函数，module和exports对象为入参的函数，一个是子依赖项的信息。重点在于实现require方法。</p><p><br /></p><p>在require方法中，传入模块id，根据模块id获取隔离作用域的执行函数fn以及依赖信息mapping，预处理一下require函数，目的是将模块中require函数入参的相对地址转为id，然后传入执行fn，最后返回module.exports对象给上级调用。</p><p><br /></p><pre data-lang=\"javascript\"><code>function bundle(graph) {\n  let modules = '';\n  // 将依赖图信息列表转为一个字符串\n  graph.forEach(mod =&gt; {\n    modules += `${mod.id}: [\n      function (require, module, exports) {\n        ${mod.code}\n      },\n      ${JSON.stringify(mod.mapping)},\n    ],`;\n  });\n\n  // 实现一个自执行函数，注入modules信息\n  const result = `\n    (function(modules) {\n      function require(id) {\n        const [fn, mapping] = modules[id];\n\n        function localRequire(name) {\n          return require(mapping[name]);\n        }\n\n        const module = { exports : {} };\n\n        fn(localRequire, module, module.exports);\n\n        return module.exports;\n      }\n\n      require(0);\n    })({${modules}})\n  `;\n  // 返回单个文件输出\n  return result;\n}</code></pre><p><br /></p><p>这个方法显然是有一些瑕疵的，比如所有的模块执行require时都会执行一遍require模块的代码，可能会导致重复引入。不过通过对require方法的简单实现，已经足够让我们理解webpack这类打包工具的本质：就是通过函数来划分作用域，通过module以及module.exports来共享数据。</p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-11T09:43:44.000Z",
    "deleted_at": null,
    "created_at": "2019-01-10T02:37:32.000Z",
    "updated_at": "2019-02-11T09:45:10.000Z",
    "published_at": "2019-02-11T09:43:44.000Z",
    "first_published_at": "2019-02-11T09:43:44.000Z",
    "word_count": 1034,
    "cover": "https://cdn.nlark.com/yuque/0/2019/png/117222/1549878224364-e2b87321-c9bc-4052-a668-0c376fa879e0.png",
    "description": "最近想学习一下webpack打包的基本原理，从官方文档找到了一个推荐链接：简单模块打包工具的细节说明是一个精简的打包工具示例：minipack，里面的源码解释非常详细，介绍了一个打包工具库主要做的工作。我快速地阅读了一下源码，并做了一下翻译和总结。简单来说打包就是从一个入口文件开始，根据模块引...",
    "custom_description": "最近想学习一下webpack打包的基本原理，从官方文档找到了一个推荐链接：简单模块打包工具的细节说明是一个精简的打包工具示例：minipack，里面的源码解释非常详细，介绍了一个打包工具库主要做的工作。我快速地阅读了一下源码，并做了一下翻译和总结。简单来说打包就是从一个入口文件开始，根据模块引...",
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1130653,
    "slug": "ihkukv",
    "title": "无标题",
    "book_id": 201855,
    "book": {
      "id": 201855,
      "type": "Column",
      "slug": "post",
      "name": "post",
      "user_id": 117222,
      "description": "技术学习",
      "creator_id": 117222,
      "public": 1,
      "items_count": 3,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-11T09:44:20.967Z",
      "updated_at": "2019-02-11T09:44:20.000Z",
      "created_at": "2019-01-10T02:22:23.000Z",
      "namespace": "daguo/post",
      "user": {
        "id": 117222,
        "type": "User",
        "login": "daguo",
        "name": "Daguo",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 2,
        "following_count": 1,
        "created_at": "2018-04-29T10:04:44.000Z",
        "updated_at": "2019-01-10T02:33:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 117222,
    "creator": {
      "id": 117222,
      "type": "User",
      "login": "daguo",
      "name": "Daguo",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/117222/1547086868453-cbb61312-ad3c-40e1-8043-7694b59e9468.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 2,
      "following_count": 1,
      "created_at": "2018-04-29T10:04:44.000Z",
      "updated_at": "2019-01-10T02:33:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": null,
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-10T02:23:07.000Z",
    "deleted_at": null,
    "created_at": "2019-01-10T02:23:07.000Z",
    "updated_at": "2019-01-10T02:23:07.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  }
]